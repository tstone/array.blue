<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Fun with Functions</title>

		<meta name="description" content="Lambda">
		<meta name="author" content="Titus Stone">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		<style type="text/css">
			.reveal pre code { padding: 20px; margin: 40px auto; max-height: 500px; }
			.reveal ul li { margin-bottom: 15px; }
			.reveal h1 { font-size: 50px; line-height: 55px; }
			.reveal h2 { font-size: 35px; text-transform: lowercase; line-height: 40px; }
			.reveal h2 code { text-transform: none; }
			.reveal h3 { font-size: 25px; }
			.reveal h5 { font-size: 14px; }
			.reveal h1 + h3 { }
			.reveal h2 + h4 { margin-top: 40px; }

			/* Slide-show specific */
			.reveal h1 + article,
			.reveal h3 + article { margin-top: 100px; }
			.reveal article { position: relative; margin-top: 50px; min-height: 300px; }
			.reveal article pre { position: relative; box-shadow: none; }
			.reveal article pre code { margin: 0; }
			.reveal pre:before { color: #aaa; font-family: "Open Sans", sans-serif; font-size: 16px; 
				position: absolute; top: 10px; right: 10px; }
			.reveal pre.ruby:before { content: "Ruby"; }
			.reveal pre.js:before { content: "Javascript"; }
			.reveal pre.scala:before { content: "Scala"; }
		</style>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

				<section>
					<h1 style="font-size: 90px; line-height: 90px;">Fun with Functions</h1>
					<h4 style="opacity: 0.75; text-transform: lowercase; font-size: 50px;">&#923; and stuff</h4>
					<h3 style="margin-top: 100px;">Titus Stone</h3>
				</section>

				<section>
					<h1>Functional composition is taking the output of one function as the input of another and keeping the final result.</h1>

					<pre class="js"><code>var r = f(g(x));</code></pre>
					<pre class="ruby"><code>r = f(g(x))</code></pre>
					<pre class="scala"><code>val r = f(g(x))</code></pre>
				</section>

				<section>
					<h1>Functional composition in context:</h1>
					<h2>In purley functional languages there are no objects, only functions.  Building up complexity means composing functions together.</h2>
					<h2>Functions define the interface and they allow smaller pieces to be re-used.  It's possible to get the same amount of code re-use as inheritance provides from functional composition.</h2>
				</section>

				<section>
					<h1>Backup: How is functional programming different from OOP?</h1>
					<blockquote style="font-size: 22px;">Functional programming and object-oriented programming are two different ways of looking at a problem. Functional programming puts special emphasis on the “verbs” of a program and ways to combine and manipulate them. Object-oriented programming puts special emphasis on “nouns” and attaches verbs to them. The two approaches are almost inverses of each other, with one being “top down” and the other “bottom up.”</blockquote>
					<p style="display: block; margin-top: 20px; font-size: 24px;"><emphasis>Scala in Depth</emphasis> by Joshua D. Suereth</p>
				</section>

				<section>
					<h1>Idioms of Functional Programming:</h1>
					<h2>Algorithms</h2>
					<ul>
						<li>Immutable values</li>
						<li>No global state</li>
						<li>Isolated side effects</li>						
					</ul>

					<h2>Architecture</h2>
					<ul>
						<li>Types</li>
						<li>Lazy evaluation</li>
						<li>Composition of functions</li>
						<li>Monads</li>
					</ul>
				</section>

				<section>
					<h1>Solving a problem both ways:</h1>
					<h2>How can we find the length of a string without using #length or any length-getting function?</h2>
					<h1>algorithm:</h1>
					<ul>
						<li>Remove the first characters until there aren't any left</li>
						<li>Keep track of how many times we did this</li>
					</ul>
				</section>

				<section>
					<h1>The imperative way</h1>
					<pre class="js" style="font-size:14px;"><code>function getStringLength(s) {
  var counter = 0;
  while (s !== "") {
    counter += 0;
    s = s.substr(1);
  }
  return counter;
}</code></pre>

					<pre class="ruby" style="font-size:14px;"><code>def string_length(s)
  counter = 0
  while !s.empty? do
    counter += 1
    s = s[1..-1]
  end
  counter
end</code></pre>

					<pre class="scala" style="font-size:14px;"><code>def stringLength(input: String) = {
  var counter = 0
  var s = input
  while (s != "") {
    counter += 1
    s = s.substring(1)
  }
  counter
}</code></pre>
				</section>

				<section>
					<h1>The functional way</h1>

					<pre class="js"><code>function getStringLength(s, length) {
  length = length || 0;
  return s === "" ? length : getStringLength(s.substr(1), length + 1);
}</code></pre>

					<pre class="ruby"><code>def string_length(s, length=0)
  s.empty? ? length : string_length(s[1..-1], length + 1)
end</code></pre>

					<pre class="scala"><code>def stringLength(s: String, length: Int = 0): Int =
  if (s.isEmpty) length else stringLength(s.tail, length + 1)</code></pre>
				</section>

				<section>
					<h1>Ok, back to <code>f(g(x))</code></h1>
				</section>

				<section>
					<h1>Let's make it more interesting:</h1>
					<h2>What if  the return from <code>g</code> is a function and the input to <code>f</code> is a function?</h2>

					<pre class="js"><code>function g(x) {
  return function(y){ return x + y; };
};
var r = f(g(x));</code></pre>

					<pre class="ruby"><code>def g(x)
  Proc.new { |y| x + y }
end
r = f(g(x))</code></pre>

					<pre class="scala"><code>def g(x: Int) =
  (y: Int) => x + y
val r = f(g(x))</code></pre>
				</section>

				<section>
					<h1>In Javascript:</h1>
					<h2>How is <code>x</code> accessible inside the inner function?</h2>
					<h2>The inner function will 'snapshot' the outer context -- a "closure"</h2>
					<h2>All 3 languages support closure</h2>
					<pre class="js"><code>function g(x) {
  return function(y) { return x + y; }
}</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>Executable code blocks are created with a ruby object: <code>Proc</code></h2>
					<pre class="ruby"><code>Proc.new { doStuff }</code></pre>

					<h2>They can receive arguments just like a regular do/end block</h2>
					<pre class="ruby"><code>Proc.new { |a, b| ... }</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2><code>lambda</code> is a special Proc in which the following is true:</h2>
					<ul>
						<li>The number of arguments are validated</li>
						<li><code>return</code> returns only the Proc, not the outer scope</li>
					</ul>
					<pre class="ruby"><code>l = lambda { |x, y| x + y }</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>Both Proc's and lambdas can be called manually with either method:</h2>
					<ul>
						<li>g.call(parameters)</li>
						<li>g[parameters]</li>
					</ul>

					<pre class="ruby"><code>p = Proc.new { |x, y| x + y }

# equivalent:
p.call(1, 2)
p[1, 2]
</code></pre>
				</section>

				<section>
					<h1>In Scala</h1>
					<h2>Scala allows executable blocks to be defined on the fly as "function literals"</h2>
					<pre class="scala"><code>(y: Int) => x + y</code></pre>
				</section>

				<section>
					<h1>In Scala</h1>
					<h2>In some cases where the compiler cannot infer the type, the type of parameters must be explicility specified <code>: Int</code></h2>
					<pre class="scala"><code>(y: Int)</code></pre>
				</section>

				<section>
					<h1>Example</h1>

					<pre class="js"><code>var greaterThan = function(b) {
  return function(a) { return a > b; }
}
var x = [1, 2, 3].filter(greaterThan(3));</code></pre>
					<pre class="ruby"><code>def greater_than(b)
  Proc.new { |a| a > b }
end
x = [1, 2, 3].select(&greater_than(2))</code></pre>
					<pre class="scala"><code>def greaterThan(b: Int) = (a: Int) => a > b
val x = List(1, 2, 3).filter(greaterThan(2))</code></pre>
				</section>

				<section>
					<h1>In Javascript:</h1>
					<h2>Array#filter builds a new array with all elements for which the function evaluates true</h2>
					<pre class="js"><code>// equivalent functionality:

[1, 2, 3].filter(greaterThan(2));

[1, 2, 3].filter(function(x){
  return x > 2;
})

// returns: [3]</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>Passing an executable block as an argument must be flagged with <code>&</code></h2>
					<pre class="ruby"><code>x = [1, 2, 3].select(&greaterThan(2))</code></pre>
				</section>

				<section>
					<h1>The function <code>greaterThan</code> as previously implemented is actually a partially applied function</h1>
					<h2>We could think of a simple implementation of <code>greaterThan</code> as actually taking two arguments:</h2>

					<pre class="js"><code>function greaterThan(a, b) { return a > b; }</code></pre>
					<pre class="ruby"><code>def greater_than?(a, b) { a > b }</code></pre>
					<pre class="scala"><code>def greaterThan(a: Int, b: Int) = a > b</code></pre>
				</section>

				<section>
					<h1>The version of <code>greaterThan</code> which takes a single argument and returns a function is partly applied</h1>
					<h2>It can be stored for later use or executed a second time to fully apply it.</h2>
					<pre class="js"><code>expect(greaterThan(8)(3)).toEqual(11)</code></pre>
					<pre class="ruby"><code>greater_than(8)[3].should == 11</code></pre>
					<pre class="scala"><code>greaterThan(8)(3) must be equalTo(11)</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>When fully applying the proc, the second function is passed with []'s instead of ()'s</h2>
					<pre class="ruby"><code>greater_than(8)[3].should == 11</code></pre>
					<h2>It could also have #call passed to it</h2>
					<pre class="ruby"><code>greater_than(8).call(3).should == 11</code></pre>
				</section>

				<section>
					<h1>Functions can be made to return a partially when not all parameters are given: Currying</h1>
					<h2>Partially applied functions VS. Currying</h2>
					<h3><strong>Partially applied function:</strong> a function which takes multiple arguments but of which some have already been specified.</h3>
					<h3><strong>Currying:</strong> calling a function with only some arguments and getting back a partially applied function.</h3>
				</section>

				<section>
					<h1>Currying Example</h1>
					<pre class="js"><code>// not natively supported</code></pre>
					<pre class="ruby"><code>greater_than = Proc.new { |b, a| a > b }
greater_than8 = greater_than.curry[8]</code></pre>
					<pre class="scala"><code>def greaterThan (a: Int, b: Int) = a > b
val greaterThan8 = greaterThan(_:Int, 8)</code></pre>
				</section>

				<section>
					<h1>In Javascript:</h1>
					<h2>Partially applied functions can be generated with various libraries.</h2>
					<h2>Example: underscore.js's #partial method takes additional arguments that it passes to the function</h2>
					<pre class="js"><code>function greaterThan(b, a) {
  if(arguments.length < 2) {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift(greaterThan);
    return _.partial.apply(this, args);
  } else {
    return a > b;
  }
}

// store for later
var greaterThan8 = greaterThan(8);

// or use in place
arr.filter(greaterThan(8));</code></pre>
				</section>

				<section>
					<h1>In Javascript:</h1>
					<h2>Weirdness:  The source function has to have the arguments in the wrong order because partialy functions can only be created by passing in the args from left to right</h2>
					<pre class="js"><code>function greaterThan(b, a) {
  // ...
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift(greaterThan);
    return _.partial.apply(this, args);</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>Just like the javascript implementation, the arguments must be curried in order of left to right</h2>
					<pre class="ruby"><code>greater_than = Proc.new { |b, a| a > b }
greater_than8 = greater_than.curry[8]</code></pre>
				</section>

				<section>
					<h1>In Ruby:</h1>
					<h2>Opinion: this isn't real currying.</h2>
					<h2>#curry should be named #partial.</h2>
					<h2>Real currying would look like:</h2>
					<pre class="ruby"><code>greater_than = Proc.new { |b, a| a > b }
greater_than8 = greater_than[8]</code></pre>
					<h2>It's a matter of responsibility: <br/>Is the callee making an partially applied function or the caller?</h2>
				</section>

				<section>
					<h1>In Scala:</h1>
					<h2>Unapplied arguments are specified with the syntax <code>_:Type</code></h2>
					<pre class="scala"><code>def greaterThan (a: Int, b: Int) = a > b
val greaterThan8 = greaterThan(_:Int, 8)</code></pre>
					<h2>The function parameters can be curried in any order.</h2>
				</section>

				<section>
					<h1>Questions for discussion:</h1>
					<ul>
						<li>Do partially applied or curried functions have a place in everyday business coding?</li>
						<li>Functional programming represents a completely new paradigm.  How are new paradigms introduced to an entire team?</li>
						<li>For that matter, when should a team choose to apply entirely new (possibly difficult) concepts or choose the lowest common denominator?</li>
						<li>Other thoughts?</li>
					</ul>
				</section>
				
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme,
				transition: Reveal.getQueryHash().transition || 'default',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
